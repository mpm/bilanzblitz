# frozen_string_literal: true

require 'json'
require 'yaml'

module Contrib
  module SKR03Mapping
    module Generators
      # Builds final JSON mapping files and CSV account list from validated YAML mappings.
      #
      # Takes the manually-reviewed YAML mapping files (skr03-section-mapping.yml and
      # skr03-presentation-rules.yml) and combines them with HGB structures and SKR03
      # OCR results to generate final output files used by the BilanzBlitz application.
      #
      # Output files:
      # - bilanz-sections-mapping.json: Balance sheet structure with account codes
      # - guv-sections-mapping.json: P&L structure with account codes
      # - skr03-accounts.csv: Complete account list with CIDs and presentation rules
      class ClassificationJsonBuilder
        # Initializes the builder with file paths.
        #
        # @param mapping_path [String] Path to skr03-section-mapping.yml
        # @param ocr_path [String] Path to skr03-ocr-results.json
        # @param presentation_rules_path [String, nil] Path to skr03-presentation-rules.yml (optional)
        # @param bilanz_aktiva_path [String] Path to hgb-bilanz-aktiva.json
        # @param bilanz_passiva_path [String] Path to hgb-bilanz-passiva.json
        # @param guv_path [String] Path to hgb-guv.json
        def initialize(
          mapping_path: 'skr03-section-mapping.yml',
          ocr_path: 'skr03-ocr-results.json',
          presentation_rules_path: 'skr03-presentation-rules.yml',
          bilanz_aktiva_path: 'hgb-bilanz-aktiva.json',
          bilanz_passiva_path: 'hgb-bilanz-passiva.json',
          guv_path: 'hgb-guv.json'
        )
          @mapping = YAML.load_file(mapping_path)
          @ocr_path = ocr_path
          @bilanz_aktiva = JSON.parse(File.read(bilanz_aktiva_path))
          @bilanz_passiva = JSON.parse(File.read(bilanz_passiva_path))
          @guv = JSON.parse(File.read(guv_path))

          # Load presentation rules mapping if available
          @presentation_rules = load_presentation_rules(presentation_rules_path)

          # Build SKR03 classification → account codes mapping
          @skr03_by_classification = build_skr03_index

          # Build SKR03 classification name → hierarchical cid mapping
          @skr03_classification_to_cid = build_classification_to_cid_mapping

          # Build SKR03 classification name → presentation rule mapping
          @skr03_classification_to_rule = build_classification_to_rule_mapping
        end

        # Builds all data structures (bilanz, guv, csv).
        #
        # @return [Hash] Hash with :bilanz, :guv, and :csv_data keys
        def build
          {
            bilanz: build_bilanz_structure,
            guv: build_guv_structure,
            csv_data: build_csv_data
          }
        end

        # Writes bilanz JSON to file.
        #
        # @param output_path [String] Path to output file
        # @param data [Hash] Bilanz data from build()[:bilanz]
        def write_bilanz_json(output_path, data)
          File.open(output_path, "w") do |f|
            f.write JSON.pretty_generate(data)
          end
        end

        # Writes GuV JSON to file.
        #
        # @param output_path [String] Path to output file
        # @param data [Hash] GuV data from build()[:guv]
        def write_guv_json(output_path, data)
          File.open(output_path, "w") do |f|
            f.write JSON.pretty_generate(data)
          end
        end

        # Writes accounts CSV to file.
        #
        # @param output_path [String] Path to output file
        # @param csv_data [Array<Hash>] CSV data from build()[:csv_data]
        def write_csv(output_path, csv_data)
          File.open(output_path, "w") do |f|
            f.puts "# This file was automatically generated by Contrib::SKR03Mapping::Generators::ClassificationJsonBuilder"
            f.puts "# Columns: code; flags; range; cid; presentation_rule; description"
            csv_data.each do |row|
              f.puts "#{row[:code]};#{row[:flags]};#{row[:range]};#{row[:cid]};#{row[:presentation_rule]};#{row[:description]}"
            end
          end
        end

        private

        # Load presentation rules from YAML file
        def load_presentation_rules(rules_path)
          return nil unless File.exist?(rules_path)

          YAML.load_file(rules_path)
        rescue StandardError => e
          puts "Warning: Failed to load presentation rules: #{e.message}"
          nil
        end

        # Build bilanz structure
        def build_bilanz_structure
          {
            aktiva: build_balance_sheet_side(@bilanz_aktiva, @mapping["aktiva"], "aktiva"),
            passiva: build_balance_sheet_side(@bilanz_passiva, @mapping["passiva"], "passiva")
          }
        end

        # Build index: SKR03 classification name → account codes
        def build_skr03_index
          ocr_data = JSON.parse(File.read(@ocr_path))

          # Parse all account codes
          all_codes = []
          ocr_data.each do |row|
            classification_name = row[0]&.strip || ""
            right_column = row[1]

            next if classification_name.empty? && right_column.nil?

            items = right_column&.split(";")&.map(&:strip)
            next unless items

            account_codes = items.select { |item| item =~ /\d{4,5}/ }
            account_codes.each do |ac|
              all_codes << [ classification_name, ac ]
            end
          end

          # Parse and deduplicate
          parsed_codes = Utils::ParserTools.deduplicate_by_code(
            all_codes.map do |code_tuple|
              (classification, code_info) = code_tuple
              result = Utils::ParserTools.parse_code_string(code_info)
              result[:classification] = classification
              if result[:code] == ""
                raise "ERROR! parse_code_string failed for #{code_info.inspect}"
              end
              result
            end.select { |pc| (Utils::ParserTools::PROG_FUNC_FLAGS & pc[:flags].split(" ")).size == 0 }
          )

          # Build index
          index = Hash.new { |h, k| h[k] = [] }
          parsed_codes.each do |pc|
            classification = pc[:classification]
            code = pc[:code]
            index[classification] << code if classification && code
          end

          # Sort codes
          index.each { |_, codes| codes.sort! }

          index
        end

        # Build balance sheet side (aktiva or passiva)
        def build_balance_sheet_side(structure, mapping, side)
          result = {}
          # Add balance sheet prefix: b.aktiva or b.passiva
          prefix = "b.#{side}"

          structure.each do |section_name, section_data|
            # Find mapping for this section
            section_mapping = find_mapping_for_name(mapping, section_name)

            if section_mapping
              section_id = find_id_for_mapping(mapping, section_mapping)
              # Prepend balance sheet prefix to section_id
              full_section_id = "#{prefix}.#{section_id}"
              result[section_name] = build_balance_section(section_name, section_data, section_mapping, full_section_id, side)
            else
              # No mapping found - create empty structure
              result[section_name] = {
                rsid: nil,
                skr03_classification: nil,
                codes: []
              }
            end
          end

          result
        end

        def build_balance_section(name, data, mapping, path_prefix, side)
          meta = mapping["_meta"] if mapping.is_a?(Hash)

          classification_field = meta ? (meta["skr03_classification"] || meta["skr03_category"]) : (mapping["skr03_classification"] || mapping["skr03_category"])

          section = {
            rsid: path_prefix,
            skr03_classification: classification_field,
            codes: get_codes_for_mapping(meta || mapping)
          }

          # Process items array
          if data.is_a?(Array) && !data.empty?
            section[:items] = data.map do |item|
              if item["name"] && !item["name"].empty?
                # Item with name
                item_mapping = find_mapping_for_name(mapping, item["name"])
                if item_mapping
                  item_id = find_id_for_mapping(mapping, item_mapping)
                  build_balance_item(item, item_mapping, "#{path_prefix}.#{item_id}")
                else
                  build_empty_item(item)
                end
              elsif item["children"]
                # Item without name, but with children
                build_nameless_item(item, mapping, path_prefix)
              else
                build_empty_item(item)
              end
            end
          end

          section
        end

        def build_balance_item(item, mapping, path_prefix)
          meta = mapping["_meta"] if mapping.is_a?(Hash)

          classification_field = meta ? (meta["skr03_classification"] || meta["skr03_category"]) : (mapping["skr03_classification"] || mapping["skr03_category"])

          item_obj = {
            name: item["name"],
            rsid: path_prefix,
            skr03_classification: classification_field,
            codes: get_codes_for_mapping(meta || mapping)
          }

          # Process children
          if item["children"] && !item["children"].empty?
            item_obj[:children] = item["children"].map do |child_name|
              clean_child_name = child_name.gsub(/;$/, '')
              child_mapping = find_mapping_for_name(mapping, clean_child_name)

              if child_mapping
                child_id = find_id_for_mapping(mapping, child_mapping)
                {
                  name: clean_child_name,
                  rsid: "#{path_prefix}.#{child_id}",
                  skr03_classification: child_mapping["skr03_classification"] || child_mapping["skr03_category"],
                  codes: get_codes_for_mapping(child_mapping)
                }
              else
                {
                  name: clean_child_name,
                  rsid: nil,
                  skr03_classification: nil,
                  codes: []
                }
              end
            end
          end

          item_obj
        end

        def build_nameless_item(item, mapping, path_prefix)
          {
            name: "",
            codes: "",
            children: item["children"].map do |child_name|
              clean_child_name = child_name.gsub(/;$/, '')
              child_mapping = find_mapping_for_name(mapping, clean_child_name)

              if child_mapping
                child_id = find_id_for_mapping(mapping, child_mapping)
                {
                  name: clean_child_name,
                  rsid: "#{path_prefix}.#{child_id}",
                  skr03_classification: child_mapping["skr03_classification"] || child_mapping["skr03_category"],
                  codes: get_codes_for_mapping(child_mapping)
                }
              else
                {
                  name: clean_child_name,
                  rsid: nil,
                  skr03_classification: nil,
                  codes: []
                }
              end
            end
          }
        end

        def build_empty_item(item)
          {
            name: item["name"] || "",
            rsid: nil,
            skr03_classification: nil,
            codes: []
          }
        end

        # Build GuV structure
        def build_guv_structure
          result = {}

          @guv.each do |section_name, children|
            section_mapping = find_mapping_for_name(@mapping["guv"], section_name)

            if section_mapping
              section_id = find_id_for_mapping(@mapping["guv"], section_mapping)

              section = {
                rsid: "guv.#{section_id}",
                skr03_classification: section_mapping["skr03_classification"] || section_mapping["skr03_category"],
                codes: get_codes_for_mapping(section_mapping)
              }

              # Process children
              if children && !children.empty?
                section[:children] = children.map do |child_name|
                  child_mapping = find_mapping_for_name(section_mapping, child_name)

                  if child_mapping
                    child_id = find_id_for_mapping(section_mapping, child_mapping)
                    {
                      name: child_name,
                      rsid: "guv.#{section_id}.#{child_id}",
                      skr03_classification: child_mapping["skr03_classification"] || child_mapping["skr03_category"],
                      codes: get_codes_for_mapping(child_mapping)
                    }
                  else
                    {
                      name: child_name,
                      rsid: nil,
                      skr03_classification: nil,
                      codes: []
                    }
                  end
                end
              end

              result[section_name] = section
            else
              result[section_name] = {
                rsid: nil,
                skr03_classification: nil,
                codes: []
              }
            end
          end

          result
        end

        # Find mapping entry for a given category name
        def find_mapping_for_name(mapping, name)
          return nil unless mapping.is_a?(Hash)

          # Check if any entry has this name
          mapping.each do |key, value|
            next if key == "_meta"

            if value.is_a?(Hash)
              # Check _meta if present
              if value["_meta"] && value["_meta"]["name"] == name
                return value
              end

              # Check direct name match
              if value["name"] == name
                return value
              end
            end
          end

          nil
        end

        # Find the ID (key) for a mapping entry
        def find_id_for_mapping(mapping, target)
          return nil unless mapping.is_a?(Hash)

          mapping.each do |key, value|
            next if key == "_meta"

            if value.is_a?(Hash)
              # Check if this is the target
              if value == target
                return key
              end

              # Check _meta match
              if value["_meta"] && value == target
                return key
              end
            end
          end

          nil
        end

        # Get account codes for a mapping entry
        def get_codes_for_mapping(mapping)
          return [] unless mapping.is_a?(Hash)

          skr03_classification = mapping["skr03_classification"] || mapping["skr03_category"]
          return [] if skr03_classification.nil?

          @skr03_by_classification[skr03_classification] || []
        end

        # Build mapping from SKR03 classification name to hierarchical cid
        def build_classification_to_cid_mapping
          mapping = {}

          # Map aktiva classifications
          walk_mapping(@mapping["aktiva"], "b.aktiva", mapping)

          # Map passiva classifications
          walk_mapping(@mapping["passiva"], "b.passiva", mapping)

          # Map GuV classifications
          walk_mapping(@mapping["guv"], "guv", mapping)

          mapping
        end

        # Recursively walk mapping structure to build SKR03 classification → cid mapping
        def walk_mapping(node, path, mapping)
          return unless node.is_a?(Hash)

          node.each do |key, value|
            next if key == "_meta"

            if value.is_a?(Hash)
              # Get the SKR03 classification name for this node
              skr03_classification = nil
              if value["_meta"]
                skr03_classification = value["_meta"]["skr03_classification"] || value["_meta"]["skr03_category"]
              elsif value["skr03_classification"]
                skr03_classification = value["skr03_classification"]
              elsif value["skr03_category"]
                skr03_classification = value["skr03_category"]
              end

              # Map it to the hierarchical cid
              if skr03_classification
                full_path = "#{path}.#{key}"
                mapping[skr03_classification] = full_path
              end

              # Recurse into children
              walk_mapping(value, "#{path}.#{key}", mapping)
            end
          end
        end

        # Build mapping from SKR03 classification name to presentation rule
        def build_classification_to_rule_mapping
          mapping = {}
          return mapping unless @presentation_rules && (@presentation_rules["classifications"] || @presentation_rules["categories"])

          source = @presentation_rules["classifications"] || @presentation_rules["categories"]

          source.each do |classification_name, classification_data|
            rule = classification_data["detected_rule"]
            accounts = classification_data["accounts"] || []

            # Map each account code to its rule (via classification)
            accounts.each do |account_code|
              mapping[account_code] = rule
            end

            # Also map the classification name directly
            mapping["classification:#{classification_name}"] = rule
          end

          mapping
        end

        # Get presentation rule for an account code or classification
        def get_presentation_rule(account_code, classification_name)
          return nil unless @presentation_rules

          # First check if we have a direct account mapping
          rule = @skr03_classification_to_rule[account_code]
          return rule if rule

          # Then check if we have a classification mapping
          rule = @skr03_classification_to_rule["classification:#{classification_name}"]
          return rule if rule

          # Try to find the classification in the presentation rules
          source = @presentation_rules["classifications"] || @presentation_rules["categories"]
          if source && source[classification_name]
            return source[classification_name]["detected_rule"]
          end

          nil
        end

        # Build CSV data array
        def build_csv_data
          ocr_data = JSON.parse(File.read(@ocr_path))

          # Parse all account codes
          all_codes = []
          ocr_data.each do |row|
            classification_name = row[0]&.strip || ""
            right_column = row[1]

            next if classification_name.empty? && right_column.nil?

            items = right_column&.split(";")&.map(&:strip)
            next unless items

            account_codes = items.select { |item| item =~ /\d{4,5}/ }
            account_codes.each do |ac|
              all_codes << [ classification_name, ac ]
            end
          end

          # Parse and deduplicate
          parsed_codes = Utils::ParserTools.deduplicate_by_code(
            all_codes.map do |code_tuple|
              (classification, code_info) = code_tuple
              result = Utils::ParserTools.parse_code_string(code_info)
              result[:classification] = classification
              if result[:code] == ""
                raise "ERROR! parse_code_string failed for #{code_info.inspect}"
              end
              result
            end.select { |pc| (Utils::ParserTools::PROG_FUNC_FLAGS & pc[:flags].split(" ")).size == 0 }
          )

          # Build CSV row data
          parsed_codes.map do |pc|
            # Get hierarchical classification ID from SKR03 classification name
            classification_id = @skr03_classification_to_cid[pc[:classification]] || ""

            # Get presentation rule for this account/classification
            presentation_rule = get_presentation_rule(pc[:code], pc[:classification]) || ""

            {
              code: pc[:code],
              flags: pc[:flags],
              range: pc[:range],
              cid: classification_id,
              presentation_rule: presentation_rule,
              description: pc[:description]
            }
          end
        end
      end
    end
  end
end
